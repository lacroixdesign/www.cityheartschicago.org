# Allow larger uploads
client_max_body_size  64M;

gzip on;
gzip_buffers 16 8k;
gzip_comp_level 6;
gzip_http_version 1.1;
gzip_min_length 10;
gzip_types text/plain text/css image/png image/gif image/jpeg application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript im$
gzip_vary on;
gzip_proxied any;
gzip_disable "MSIE [1-6]\.(?!.*SV1)";

# Deny hidden files (.htaccess, .htpasswd, .DS_Store).
location ~ /\. {
  deny            all;
  access_log      off;
  log_not_found   off;
}

location / {
  index   index.php index.html index.htm;
  # This is cool because no php is touched for static content.
  # include the "?$args" part so non-default permalinks doesn't break when using query string
  try_files   $uri $uri/ /index.php?$args;
}

# location / {
#   try_files $uri $uri/ @rewrites;
# }

# location @rewrites {
#   rewrite ^(.*) /index.php?p=$1 last;
# }

# default handling of .php
# location ~ \.php {
#   include fastcgi_params;

#   fastcgi_split_path_info ^(.+\.php)(/.*)$;
#   fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
#   # try_files resets $fastcgi_path_info, see http://trac.nginx.org/nginx/ticket/321, so we use the if instead
#   fastcgi_param PATH_INFO $fastcgi_path_info if_not_empty;

#   if (!-f $document_root$fastcgi_script_name) {
#     # check if the script exists
#     # otherwise, /foo.jpg/bar.php would get passed to FPM, which wouldn't run it as it's not in the list of allowed extensions, but this check is a good idea anyway, just in case
#     return 404;
#   }

#   fastcgi_pass heroku-fcgi;
# }

# location ~ \.php$ {
#   # try_files $uri =404;
#   # fastcgi_split_path_info ^(.+\.php)(/.+)$;
#   # fastcgi_pass unix:/var/run/php5-fpm.sock;
#   # fastcgi_index index.php;
#   # include fastcgi_params;
#   #NOTE: You should have "cgi.fix_pathinfo = 0;" in php.ini
#   include fastcgi.conf;
#   fastcgi_intercept_errors on;
#   fastcgi_pass heroku-fcgi;
# }

location ~ ^/(cache)/  {
  expires 1y;
}

error_page 404 /index.php;
